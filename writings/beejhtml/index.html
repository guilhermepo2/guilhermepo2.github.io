<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Guia de Programação para Redes, por Beej</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  </head>
  <body>
    <div class="container">
    <!-- CABEÇALHO COM INFORMAÇÕES DO AUTOR -->
    <h1>Guia de Programação para Redes, por Beej</h1>
    <h2>Utilizando Sockets de Internet</h2>

    <p>
      <b>Brian "Beej Jorgensen" Hall</b>
      <br>
      <a href="mailto:beej@beej.us">beej@beej.us</a>
      <br><br>
      <b>Tradução:<br> Guilherme Pacheco de Oliveira</b>
      <br>
      <a href="http://guilhermepo2.github.io">website</a> | <a href="mailto:guilherme.061@gmail.com">guilherme.061@gmail.com</a>
    </p>

    <p>
      <span>Versão 3.0.21</span>
      <br>
      <span>8 de Junho de 2016</span>
    </p>

    <p>
      Copyright © 2015 Brian "Beej Jorgensen" Hall
    </p>

    <hr>
    <!-- aqui fica um link para o conteúdo, tipo um sumário -->

    <ol>
      <li>Introdução</li>
    </ol>

    <hr>

    <!--
    =============================================================
              INTRODUÇÃO
    =============================================================
    -->

    <section id="#intro">
      <h2>1. Introdução</h2>
      <hr>
      <p>Hey!  Programação com Sockets te deixou para baixo?  Achou isso um pouco complicado de aprender
      	através das páginas <b>man</b>?  Você quer programar para a Internet, mas você não tem tempo para
      	bisbilhotar as várias <b>structs</b> tentando descobrir se você deve chamar <b>bind()</b>
      	antes de <b>connect()</b>, etc., etc.</p>

        <p>Bom, adivinha só! Eu já fiz todo esse trabalho sujo, e agora estou disposto a
        compartilhar minhas experiências com todo mundo! Você veio para o lugar certo. Esse
        documento deve dar para um programador C competente o que ele(a) precisa para começar a
        entender essa coisa de redes.</p>

        <p>E veja só: Eu finalmente cheguei ao futuro e atualizei o Guia para IPv6! Aproveite!</p>
    </section>

    <!--
    =============================================================
              PÚBLICO ALVO
    =============================================================
    -->
    <section id="audience">
    <h3>Público Alvo</h3>

    <p>Esse documento foi escrito como uma forma de tutorial e não uma
    referência completa. É uma leitura melhor para indivíduos que estão apenas
    começando com programação com sockets e estão procurando por uma base.
    Certamente não é, de forma alguma, o guia <emp>completo e total</emp> sobre programação
    com sockets.</p>

    <p>Porém espero que seja o suficiente para que aquelas páginas man comecem
    	a fazer sentido<smiley/></p>
    </section>
    <!--
    =============================================================
              PLATAFORMA E COMPILADOR
    =============================================================
    -->

    <section id="platform">
    <h3>Plataforma e Compilador</h3>

    <p>O código contido nesse documento foi compilado em um computador Linux
    utilizando o compilador GNU <b>gcc</b>. Entretanto,
    ele deve poder ser compilado em qualquer plataforma que utiliza <b>gcc</b>.
    Naturalmente, isso não se aplica se você está programando em um Windows, veja a
    <a href="#windows">seção de programação para Windows</a>, abaixo</p>

    </section>

    <!--
    =============================================================
              PÁGINA OFICIAL
    =============================================================
    -->

    <section id="homepage">
    <h3>Página Oficial e Livros à venda</h3>

    <p>A localização oficial desse documento é <a href="http://beej.us/guide/bgnet/">
      http://beej.us/guide/bgnet/</a>. Nela você
    irá encontrar exemplos de códigos e tradução do guia para várias
    linguagens (Provavelmente você encontrou essa tradução nessa página).</p>

    <p>Para comprar cópias impressas do guia (algumas pessoas as chamam de "livros"),
    visite <a href="http://beej.us/guide/url/bgbuy">http://beej.us/guide/url/bgbuy</a>.
    Eu vou ficar agradecido pela compra pois ela ajuda a sustentar meu estilo de
    vida de escrever documentos!</p>

    </section>

    <!--
    =============================================================
              SOLARIS E SUNOS
    =============================================================
    -->

    <section id="solaris">
    <h3>Notas para Programadores Solaris/SunOS</h3>

    <p>Quando estiver compilando para Solari ou SunOS, você precisa especificar algumas opções extras
    na linha de comando para ligar corretamente as bibliotecas. Para fazer isso,
    simplesmente adicione "-lnsl -lsocket -lresolv"
    no fim do comando, por exemplo: </p>

    <p><code>$ cc -o server server.c -lnsl -lsocket -lresolv</code></p>

    <p>Se você ainda obtiver erros, você pode tentar adicionar "-lxnet"
    ao comando. Eu não sei o que isso faz exatamente, mas algumas pessoas parecem
    precisar disso.</p>

    <p>Outro lugar que você pode encontrar problemas é na chamada da função
    <b>setsockopt()</b>. O protótipo difere no meu Linux, então
    invés de:</p>

    <p><code>int yes=1;</code></p>

    <p>utilize:</p>

    <p><code>char yes='1';</code><p>

    <p>Como eu não tenho um SunOS. Eu não testei nenhuma das informações
    	acima, é apenas o que me disseram por email.</p>

    </section>


    <!--
    =============================================================
              WINDOWS
    =============================================================
    -->

    <section id="windows">
    <h3>Nota para programadores Windows</h3>

    <p>Nesse ponto no guia, historicamente, Eu já insultei um pouco o Windows,
    simplesmente pelo fato de que eu não gosto muito dele. Mas eu realmente devo ser justo e te dizer
    que Windows tem muitas coisas que podem ser instalas e obviamente é um Sistema Operacional que
    funciona perfeitamente.</p>

    <p>Dizem que absência faz o coração evoluir, e nesse caso, eu acredito que
    	isso seja verdade. (Ou talvez seja a idade.) Mas o que eu posso dizer é
    	que depois de mais de uma década sem utilizar SO's da Microsoft para trabalho
    	pessoal, eu estou muito mais feliz! Assim, eu posso seguramente dizer "Claro, sinta-se
    	livre para usar Windows!" ... Ok, dizer isso faz eu ranger meus dentes.</p>

    <p>Eu ainda o encorajo a utilizar <a href="https://www.linux.com">Linux</a>, <a href="http://www.bsd.org">BSD</a>, ou
    qualquer sistema Unix</p>

    <p>Mas as pessoas gostam do que elas gostam, e vocês, pessoal do Windows,
    vão ficar felizes em saber que essa informação geralmente é aplicável a vocês,
    com algumas pequenas mudanças, se tiver alguma.</p>

    <p>Uma coisa que você pode fazer é instalar <a href="http://www.cygwin.com">Cygwin</a>, que é uma coleção de ferramentas Unix
    para Windows. Eu ouvi dizer por aí que fazer isso permite que todos
    esses programas sejam compilados sem nenhuma modificação</p>

    <p>Mas alguns de vocês podem querer fazer as coisas do jeito Windows puro.
    Isso é muito corajoso de sua parte, e é isso que você deve fazer: Corra
    e comece a utilizar um sistema Unix imediatamente! Não, não, é brincadeira.
    Eu deveria ser amigável com o Windows</p>

    <p>É isso que você deve fazer (a menos que você instale <a href="http://www.cygwin.com">Cygwin</a>!): Primeiro, ignore
    quase todos os arquivos de Header que eu mencionar aqui. Tudo o que
    você precisa de incluir é: </p>

    <p><code>#include &lt;winsock.h&gt; </code></p>

    <p>Espera! Você também tem que fazer a chamada da função <b>WSAStartup()</b> antes de fazer qualquer
    outra coisa com a biblioteca de sockets. O código para fazer isso se
    parece com isso: </p>

    <p><code>#include &lt;winsock.h&gt; <br>
    &emsp;&emsp;{ <br>
        &emsp;&emsp;WSADATA wsaData;   // se isso nao funcionar<br>
        &emsp;&emsp;//WSAData wsaData; // tente isso <br>

    	  &emsp;&emsp;// MAKEWORD(1,1) for Winsock 1.1, MAKEWORD(2,0) for Winsock 2.0: <br>

        &emsp;&emsp;if (WSAStartup(MAKEWORD(1,1), &wsaData) != 0) { <br>
            &emsp;&emsp;&emsp;&emsp;fprintf(stderr, "WSAStartup failed.\n"); <br>
            &emsp;&emsp;&emsp;&emsp;exit(1); <br>
        &emsp;&emsp;}</code></p>


    <p>Você também deve dizer ao seu compilador para "linkar" a biblioteca Winsock,
    	o arquivo geralmente se chama <b>wsock32.lib</b> ou <b>winsock32.lib</b>,
    	ou <b>ws_32.lib</b> para Winsock 2.0. Se você estiver utilizando Visual C++,
    	isso pode ser feito através do menu <b>Project</b>, em <b>Settings...</b>.
    	Clique na aba <b>Link</b> e procure o campo denominado "Object/library modules".
    	Adicione <b>"wsock32.lib"</b> (ou qualquer outra biblioteca da sua preferência) para essa
    	lista. </p>

    <p>Pelo menos foi o que eu ouvi dizer.</p>

    <p>Finalmente, você precisa chamar a função <b>bWSACleanup()</b> quando você
    termina de utilizar a biblioteca de sockets. Veja sua página de ajuda
    online para detalhes.</p>

    <p>Quando você fizer isso, o resto dos exemplos nesse tutorial devem
    	funcionar, com algumas poucas exceções. Você não pode usar <b>close()</b>
    	para fechar um socket, você precisa usar <b>closesocket()</b>. Além disso,
      <b>select()</b> funciona apenas com descritores
    	de sockets e não descritores de arquivos (como <em>0</em> para
    	<b>stdin</b>).</p>

    <p>Também tem uma classe de sockets que você pode usar, <b>CSocket</b>. Verifique o guia de seu
    	compilador para mais informação.</p>

    <p>Para mais informação sobre Winsock, leia o <a href="http://tangentsoft.net/wskfaq/">
      Winsock FAQ</a> e vá a partir dele.</p>

    <p>Para finalizar, eu ouvi dizer que Window não tem a chamada<b>fork()</b> que é, infelizmente, utilizada
    em alguns exemplos. Talvez você tenha que utilizar uma biblioteca POSIX
    ou alguma outra coisa para que isso funcione, ou você pode usar <b>CreateProcess()</b>.
    <b>fork()</b> não possui parâmetros, e <b>CreateProcess()</b> leva,
    aproximadamente, 48 bilhões de parâmetros. Se você não está disposto a fazer isso,
    a função <b>CreateThread()</b> é um pouco mais
    fácil de digerir... infelizmente a discussão sobre multithreading está além do
    escopo desse documento.</p>

  </section>


    <!--
    =============================================================
              POLÍTICA DE EMAIL
    =============================================================
    -->

    <section id="emailpolicy">
    <h3>Política de Email</h3>

    <p>Geralmente eu estou disponível para ajudar através do meu email, então sinta-se livre para me enviar um, porém eu não posso
    garantir uma resposta. Eu ando muito ocupado ultimamente e algumas vezes eu
    não consigo responder alguma pergunta que você tenha. Quando isso acontece,
    eu geralmente apenas deleto a mensagem, não é nada pessoal, é só que eu nunca
    vou ter tempo o suficiente para te dar uma resposta detalhada. </p>

    <p>Por via de regra, quanto mais complexa é a pergunta, menor é a chance
    de eu responder. Se você conseguir especificar sua pergunta e especificar
    todas as informações pertinentes, como a plataforma, compilador, mensagens de erro e
    qualquer outra coisa que você ache que possa ajudar, você tem mais chances
    de conseguir uma resposta. Para mais ajuda leia: <a href="http://www.catb.org/~esr/faqs/smart-questions.html">Como Fazer
    Perguntas de um jeito Inteligente</a>.</p>

    <p>Se eu não te responder, pesquise um pouco mais e tente procurar a
    resposta, se não encontrar, então me envie outro email com a informação
    que você encontrou e talvez eu consiga te ajudar.</p>

    <p>Agora que eu te expliquei sobre como e como não escrever para mim, Eu
    gostaria de te informar que eu <em>realmente<em> aprecio todo o carinho que
    esse guia tem recebido através dos anos. Isso me deixa feliz e fico orgulhoso
    em ouvir que ele está sendo realmente utilizado! Obrigado!</p>

  </section>

    <!--
    =============================================================
              CÓPIAS
    =============================================================
    -->

    <section id="mirroring">
    <h3>Cópias</h3>

    <p><em>Nota de Tradução: O termo utilizado exatamente é "Mirroring", basicamente é uma cópia, porém geralmente
    é feita com o intuito de salvar o conteúdo em outros servidores espalhados pelo planeta. Isso faz com que o conteúdo
  seja mais tolerante à falhas, caso o site original caia, existem outros servidores disponiveis para atender, também pode
ajudar em reduzir o tempo de resposta, mas isso não é tão relevante em um documento como esse.</em></p>

    <p>Você é bem vindo para criar cópias desse site em outros lugares,
    seja público ou privado. Se você publicamente criar uma "cópia" do site e quiser que eu
    adicione um link para ele, entre em contato comigo <a href="mailto:beej@beej.us">beej@beej.us</a>.</p>

    </section>

    <!--
    =============================================================
              TRADUTORES
    =============================================================
    -->

    <section id="xlate">
    <h3>Nota para Tradutores</h3>

    <p>Se quiser traduzir este guia, escreva para mim em
    <a href="mailto:beej@beej.us">beej@beej.us</a> e eu colocarei um link para a tradução na página principal.
    Sinta-se livre para adicionar seu nome e contato na tradução</p>

    <p>Por favor observe as restrições de licença na seção de Distribuição e Copyright abaixo</p>

    <p>Se você quer que eu hospede a tradução, basta pedir. Eu posso também colocar um link
    para a tradução se você quiser hospedá-la.</p>

  </section>

    <!--
    =============================================================
              COPYRIGHT
    =============================================================
    -->

    <section id="copyright">
      <h3>Copyright e Distribuição</h3>

      <p>O Guia de Programação para Redes, por Beej é Copyright © 2015 Brian "Beej Jorgensen" Hall.</p>

      <p>Com algumas exceções para código fonte e traduções, esse trabalho é licenciado sob a "Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 License".
        Você pode ver uma cópia da licença em <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">http://creativecommons.org/licenses/by-nc-nd/3.0/</a> ou pode enviar uma carta
        para Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.</p>

      <p>Uma exceção específica para a parte de "No Derivative Works" (Sem trabalhos derivados) é: Esse guia pode ser livremente traduzido para qualquer linguagem, considerando que a tradução esteja correta e que
        o guia esteja totalmente traduzido. As mesmas restrições da licença se aplicam à tradução. A tradução também pode incluir nome e contato do tradutor.</p>

        <p>O código fonte em C apresentado nesse documento é de domínio público, ou seja, totalmente livre de qualquer restrição de licença</p>

        <p>Educadores são encorajados a recomendarem ou fornecerem cópias desse guia para seus estudantes</p>

        <p>Entre em contato com <a href="beej@beej.us">beej@beej.us</a> para mais informação.</p>
    </section>

    <!--
    =============================================================
              NOTAS DE TRADUÇÃO
    =============================================================
    -->
    <section id="notas-traducao">
      <h3>Notas de Tradução</h3>
      <p>Olá! Meu nome é Guilherme e eu atualmente estudo Ciência da Computação na Universidade Federal de Uberlândia.</p>
      <p>Eu me deparei com esse guia enquanto fazia a disciplina de <b>Sistemas Distribuidos</b>, uma disciplina do sétimo período da graduação,
      o guia me ajudou muito e eu achei ele um tanto quanto divertido de se ler, e quando olhei as traduções, percebi que não havia uma em português.</p>

      <p>Sempre me interessei em escrever e traduzir, gosto da lingua inglesa porém nunca havia tentado traduzir um documento, ou um guia, desse porte, essa tradução não está de modo algum
      finalizada ou livre de erros, muito pelo contrário. Mas caso encontre erros ou fique em dúvidas sobre algum trecho, peço que tenha paciência comigo e entre em contato para que eu possa fazer uma revisão,
    ou então caso você tenha uma correção, também sinta-se à vontade para me enviar.</p>

    <p>Você pode entrar em contato comigo através do meu email: <a href="mailto:guilherme.061@gmail.com">guilherme.061@gmail.com</a>, Se quiser entrar em contato de outra forma, ou por algum motivo queira saber mais sobre mim,
      você pode encontrar meu github, minha conta no medium e outras informações no meu website: <a href="http://guilhermepo2.github.io" target="BLANK">http://guilhermepo2.github.io</a>

      <p>Espero que você possa aprender alguma coisa com esse guia que foi traduzido por mim, boa leitura!</p>
    </section>


    <!--
    =============================================================
              O QUE SÃO SOCKETS
    =============================================================
    -->
    <section id="theory">
      <h2>O que é um socket?</h2>
      <hr>

      <p>Você ouve falar de "sockets" o tempo todo, talvez você esteja se perguntando o que exatamente é um socket.
      Bom, eis o que são sockets: <b>uma maneira de conversar com outros programas usando descritores de arquivos do Unix.</b></p>

      <p>O que?</p>

      <p>Ok - talvez você tenha ouvido algum aficionado em Unix dizer: "<em>putz... TUDO</em> em UNIX é um arquivo!".
      O que essa pessoa talvez estava falando era do fato de que quando programas Unix vão fazer qualquer tipo de operação I/O (entrada ou saída)
      , eles fazem isso lendo ou escrevendo um descritor de arquivo. Um descritor de arquivo nada mais é do que um número inteiro associado com um arquivo aberto
      . Porém (e aqui que está a sacada), esse arquivo pode ser uma conexão de rede, uma fila FIFO, um encadeamento, um terminal, um arquivo no disco ou qualquer outra coisa.
      Tudo no Unix <em>é</em> um arquivo! Então quando você quer se comunicar com outro programa pela internet, você vai fazer isso através de um descritor de arquivo. É melhor você acreditar nisso.</p>

      <p>
        "E onde eu consigo esse descritor de arquivo para comunicação em rede, espertão?" é talvez a última pergunta que esteja na sua mente nesse momento,
        mas eu vou respondê-la de qualquer forma: Você pode fazer uma chamada para a subrotina de sistema <b>socket()</b>. Ela retorna o descritor de um socket e
        você se comunica por ele utilizando as funções <a href="#sendman"><b>send()</b></a> e <a href="#recvman"><b>recv()</b></a>
      </p>

      <p>
        "Espera!" talvez você esteja dizendo nesse momento, "Se é um descritor de arquivo, por que, em nome de Netuno, eu não posso apenas usar <b>read()</b> e <b>write()</b> para me comunicar através do socket?".
        A resposta mais curta é: "Você pode!", a resposta longa é: "Você pode, mas <b>send()</b> e <b>recv()</b> oferecem um controle maior sob a transmissão de dados."
      </p>

      <p>
        E agora? Que tal isso: existem vários tipos de sockets, existem endereços de Internet DARPA (Sockets de Internet), endereços de ambiente local (Sockets Unix), endereços
        CCITT X.25 (Sockets X.25 podem ser ignorados) e provavelmente vários outros dependendo de qual distribuição Unix você utiliza. Esse documento lida apenas com o primeiro: Sockets de Internet.
      </p>

      <h3>Dois tipos de Sockets de Internet</h3>

      <p>
        O que é isso? Tem dois tipos de Sockets para Internet? Sim. Bom, não, eu estou mentindo. Tem mais, mas eu não queria te assustar. Eu só vou falar de dois tipos aqui. Exceto por essa frase, que eu vou te dizer que "Raw Sockets" também são bem poderosos e você deveria buscar saber mais sobre eles.
      </p>

      <p>
        Tudo bem. Quais são os dois tipos? Um é o Socket de Stream (fluxo); o outro é Socket de Datagrama, que vão ser chamados de "SOCK_STREAM" e "SOCK_DGRAM",
        respectivamente. Sockets de Datagrama também podem ser chamados de sockets sem conexão. (Embora você possa usar <b>connect()</b> caso queira, falarei disso mais abaixo)
      </p>

      <p>
        Sockets de Stream são confiáveis e exigem uma conexão para que haja comunicação. Se você colocar dois itens no socket na ordem "1, 2" eles chegarão na ordem "1, 2" do outro lado.
        Eles também não terão erro. Eu tenho tanta certeza que não vai ter erro que eu vou apenas colocar meus dedos no ouvido e cantar <em>lala lalala lala la la</em> se alguém disser o contrário.
      </p>

      <p>
        Mas afinal, o que utiliza sockets de stream? Bom, talvez você já ouviu falar de <b>telnet</b>. Ele usa sockets de stream. Todos os caracteres que você digita precisam chegar na mesma ordem em que foram digitados, certo?
        E mais, browsers de internet utilizam o protocolo HTTP, que utiliza sockets de stream para buscar as páginas. Curiosidade: se você utilizar o telnet para enviar "GET / HTTP/1.0" na porta 80 de qualquer website, ele vai te jogar um monte de HTML!
      </p>

      <p>
        Como sockets de stream conseguem esse nível alto de transmissão de dados? Eles usam um protocolo chamado "The Transmission Control Protocol" (Protocolo de Controle de Transmissão), também conhecido como "TCP" (veja o <a href="https://tools.ietf.org/html/rfc793">RFC 793</a>
        para informações detalhadas sobre o TCP). O protocolo TCP se assegura de que seus dados chegarão ao outro lado na mesma ordem e sem erros. Você talvez tenha ouvido "TCP" antes quando alguém disse "TCP/IP", onde "IP" significa "Internet Protocol" (Protocolo de Internet) (<a href="https://tools.ietf.org/html/rfc791">RFC 791</a>).
        O IP lida com roteamento e geralmente não é responsavel pela integridade dos dados.
      </p>

      <p>
        Legal. E sobre os sockets de datagrama? Por quê eles são chamados de sem conexão? Por que eles não são confiáveis? Bom, aqui vão uns fatos: se você enviar um datagrama, ele pode chegar, ele pode chegar fora de ordem. Se ele chegar, os dados nele estarão livres de erro.
      </p>

      <p>
        Sockets de Datagrama também utilizam o IP para roteamento, mas eles não utilizam o TCP; eles utilizam o User Datagram Protocol (Protocolo de Datagrama de Usuário), UDP. (veja <a href="https://tools.ietf.org/html/rfc768"> RFC 768 </a>)
      </p>

      <p>
        Por que eles são sem conexão? Basicamente é porque não é necessário que se mantenha uma conexão aberta igual é necessário para sockets de stream.
        Você apenas monta o pacote, coloca um cabeçalho IP com a informação do destinatário e envia. Não é necessário uma conexão. Geralmente são utilizados quando
        o TCP está indisponível ou quando a perda de alguns pacotes não significa muita coisa. Exemplo de aplicações: <b>tftp</b> (trivial file transfer protocol, um pequeno irmão do FTP),
        <b>dhcpcd</b> (um cliente CHCP), jogos multiplayer, streaming de áudio, conferência de vídeo, etc...
      </p>

      <p>
        Espera um minuto! <b>tftp</b> e <b>dhcpcd</b> são utilizados para transferir aplicações binárias de um ponto ao outro! Dados não podem ser perdidos se você espera que a aplicação funcione quando ela chegar! Que tipo de magia negra é essa?
      </p>

      <p>
        Vejamos, meu amiguinho humano, <b>tftp</b> e programas similares tem seus próprios protocolos em cima do protocolo UDP. Por exemplo,
        o protocolo tftp diz que para cada pacote enviado, quem recebeu deve enviar de volta um pacote que diz: "Eu recebi!" (um pacote "ACK").
        Se o transmissor do pacote original não receber uma resposta em, digamos, 5 segundos, ele irá retransmitir o pacote até que ele receba um ACK.
        Esse processo de reconhecimento é muito importante para a implementação de aplicações confiáveis que utilizam dos SOCK_DGRAM.
      </p>

      <p>
        Para apicações não confiáveis como jogos, áudio, vídeo, você apenas ignora os pacotes perdidos ou talvez tenta recompensar a perda de um modo inteligente.
        (Jogadores de Quake vão saber como é isso através do termo técnico: <em>accursed lag</em> (lag maldito). A palavra accursed (maldito), no caso, representa qualquer elocução extremamente profana.)
        (<b>nota: eu não sei direito o que o autor quis dizer com isso não viu...</b>)
      </p>

      <p>
        Por que alguém usaria um protocol não confiável? Duas razões: velocidade e velocidade. É muito mais rapido disparar o pacote e esquecer do que registrar o que chegou corretamente do outro lado e ter certeza de que chegou tudo em ordem e essas coisas.
        Se você está enviando mensagens de chat, TCP é ótimo, se você está enviando 40 updates por segundo da posição de um jogador para cada jogaodor, talvez não tenha tanta importância se um ou dois se perderem. Nesse caso UDP é uma ótima escolha.
      </p>

      <h3>Coisas de baixo nível e Teoria de Redes</h3>

      <p>
        Já que eu acabei de mencionar a organização de protocolos em camadas, está na hora de falar sobre como redes de computadores realmente funcionam, e de mostrar
        alguns exemplos de como um pacote <b>SOCK_DGRAM</b> é montado. Na prática você pode pular essa seção, mas é um bom contexto.
      </p>

      <br><div align="center"><img src="images/dataencap.png"><br><b>Encapsulamento de Dados</b></div></br>

      <p>
        Ei crianças! está na hora de aprender sobre <b>encapsulamento de dados!</b> Isso é muito importante. É tão importante que você também aprenderá isso se você
        atender o curso de redes de computadores aqui na Universidade do Estado de Chicago ;~). Basicamente é o seguinte: um pacote nasce, o pacote é envolvido (encapsulado)
        com um cabeçalho (header) (e raramente um rodapé (footer)) pelo primeiro protocolo (por exemplo, o protocolo TFTP), então, tudo isso (cabeçalho do TFTP incluso) é encapsulado
        novamente pelo próximo protocolo (digamos, UDP), e então novamente pelo próximo (IP), e novamente pelo último protócolo na camada física (por exemplo, Ethernet).
      </p>

      <p>
        Quando outro computador recebe o pacote, o hardware desencapsula o cabeçalho de Ethernet, o kernel faz o mesmo com os cabeçalhos IP e UDP e então, o programa TFTP desencapsula o cabeçalho TFTP, e assim,
        finalmente, ele obtém os dados.
      </p>

      <p>
        Agora eu posso finalmente falar sobre o famoso <em>Modelo de Rede de Computadores em Camadas</em> (também conhecido por ISO/OSI). Esse modelo de rede descreve um
        sistema de funcionamento de rede que possui muitas vantagens sob outros modelos. Por exemplo, você pode escrever sockets sem ligar muito como os dados são transmitidos
        fisicamente (cabo serial, ethernet, ...), pois programas em um nível mais baixo lidam com isso por você. O hardware de rede é transparente para quem está programando o socket.
      </p>

      <p>
        Sem mais delongas, eu vou apresentar todas as camadas do modelo. Lembre-se disso para as provas de redes:
        <ul>
          <li>Aplicação</li>
          <li>Apresentação</li>
          <li>Sessão</li>
          <li>Transporte</li>
          <li>Rede</li>
          <li>Enlace</li>
          <li>Camada Física</li>
        </ul>
      </p>

      <p>
        A camada física é o hardware (serial, ethernet, etc...). A camada de aplicação é tão longe da camada física quanto você
        pode imaginar, é onde os usuários interagem com a rede.
      </p>

      <p>
        Esse modelo é tão geral que você provavelmente poderia usar ele como um guia para consertar o seu carro se você quisesse.
        Um modelo em camadas mais consistente (e real) com os sistemas Unix seria:

        <ul>
          <li>Camada de aplicação (telnet, ftp, etc...)</li>
          <li>Camada de Transporte Ponto-a-Ponto (TCP, UDP)</li>
          <li>Camada de Internet (IP e Roteamento)</li>
          <li>Camada de Acesso à Rede (Ethernet, wi-fi, etc...)</li>
        </ul>
      </p>

      <p>Talvez agora você consiga ver como esse modelo corresponde ao encapsulamento dos dados originais</p>

      <p>
        Viu só quanto trabalho dá montar um pacote? E você tem que digitar você mesmo os cabeçalhos utilizando o comando <b>"cat"</b>! Brincadeira.
        Tudo o que você tem que fazer para sockets de stream é enviar (<b>send()</b>) os dados. Tudo o que você tem que fazer para um socket
        de datagrama é encapsular o pacote com o método de sua escolha e enviar (<b>sendto()</b>). O kernel monta a camada de transporte e a camada de internet para você e
        o hardware faz o <em>Acesso à Rede</em>. Ah... a tecnologia moderna...
      </p>

      <p>
        Aqui acaba nossa breve introdução à teoria de redes de computadores. Ah, espera, eu esqueci de te dizer tudo que eu queria te dizer sobre roteamento: Nada! Isso mesmo, eu não vou nem falar sobre isso.
        O roteamento encapsula o pacote para o cabeçalho IP, consulta sua tabela de roteamento, bla bla bla. Veja o <a href="https://tools.ietf.org/html/rfc791">IP RFC</a> se você realmente liga. Se você nunca aprender sobre isso,
        bom, você vai sobreviver.
      </p>
    </section>

    <!--
    =============================================================
              ENDEREÇOS DE IP, STRUCTS, E MUNGING DE DADOS
    =============================================================
    -->
    <section id="ipstructdata">
      <hr>
      <h2>Endereços de IP, structs e "Munging" de Dados</h2>
      (nota: munging é um jargão em computação que se refere a uma série de mudanças em um arquivo ou dado que podem ser destrutivas ou irrevogáveis)
      <hr>

      <p>
        Aqui é a parte do jogo em que vamos falar de código para variar um pouco.
      </p>

      <p>
        Mas antes, vamos discutir mais coisas não relacionadas a código! Oba! Primeiro eu quero falar só um pouquinho sobre endereços de IP e portas.
        Em seguida, vamos falar como as API de sockets guardam e manipulam endereços de IP e outros dados.
      </p>

      <h3>Endereços de IP, versão 4 e 6</h3>
    </section>


  </div>
  </body>
</html>
